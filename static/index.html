<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speech Recording</title>
  <style>
    body { font-family: Segoe UI, Arial, sans-serif; background: #fff; color:#000; margin:0; }
    .wrap { max-width: 760px; margin: 0 auto; padding:16px; }
    .card { border:1px solid #ccc; border-radius:10px; padding:12px; margin-top:12px; }
    button { cursor:pointer; }
  </style>
</head>
<body>
<div class="wrap">
  <h2>Speech Recording</h2>
  <div style="font-size:15px;margin-bottom:12px;">Total sentences: <span id="totalN"></span></div>

  <!-- Screen 0: Mic Check -->
  <div id="scrMic" class="card">
    <div style="font-weight:700;margin-bottom:8px;">Microphone Check</div>
    <div style="margin-bottom:10px;">Enable your microphone and make a short test recording. This test is not saved.</div>
    <div style="display:flex;gap:8px;margin:8px 0;">
      <button id="micEnable" style="padding:8px 12px;border-radius:6px;background:#2563eb;color:#fff;border:0">Enable microphone</button>
      <button id="micRec"  style="padding:8px 12px;border-radius:6px;background:#16a34a;color:#fff;border:0">üî¥ Start recording</button>
      <button id="micStop" disabled style="padding:8px 12px;border-radius:6px;background:#dc2626;color:#fff;border:0">‚èπ Stop recording</button>
      <button id="micNext" disabled style="margin-left:auto;padding:8px 12px;border-radius:6px;background:#111827;color:#fff;border:0">Continue</button>
    </div>
    <div id="micStatus" style="padding:8px;border:1px dashed #999;border-radius:6px;">Waiting for mic permission‚Ä¶</div>
    <div id="micPlayer" style="margin-top:10px"></div>
  </div>

  <!-- Screen 1: Participant ID -->
  <div id="scrId" class="card" style="display:none;">
    <label style="font-weight:600;">Participant ID:</label>
    <input id="pid" type="text" placeholder="001" style="margin:0 8px;padding:6px 10px;border:1px solid #888;border-radius:6px">
    <button id="go" style="padding:6px 12px;border-radius:6px;background:#2563eb;color:#fff;border:0">Start</button>
    <div id="warn" style="color:#b91c1c;display:none;margin-top:6px">Use only letters, numbers, _ or -</div>
    <div id="pidTaken" style="color:#b91c1c;display:none;margin-top:6px"></div>
  </div>

  <!-- Screen 2: Task -->
  <div id="scrTask" class="card" style="display:none;">
    <div id="prog" style="font-size:14px;margin-bottom:4px;"></div>
    <div id="phaseLabel" style="font-weight:700;margin:6px 0;"></div>
    <div id="hint" style="margin-bottom:12px;font-size:15px;"></div>

    <div class="card" style="background:#fff;">
      <div id="promptLabel" style="font-size:13px;margin-bottom:4px;">Sentence:</div>
      <div id="sent" style="font-size:19px;line-height:1.5;"></div>
    </div>

    <div style="display:flex;gap:8px;margin:8px 0">
      <button id="rec"  style="padding:8px 12px;border-radius:6px;background:#16a34a;color:#fff;border:0">üî¥ Start recording</button>
      <button id="stop" disabled style="padding:8px 12px;border-radius:6px;background:#dc2626;color:#fff;border:0">‚èπ Stop recording</button>
      <button id="save" disabled style="padding:8px 12px;border-radius:6px;background:#2563eb;color:#fff;border:0">üíæ Save & Continue</button>
    </div>

    <div id="status" style="padding:8px;border:1px dashed #999;border-radius:6px;">Ready‚Ä¶</div>
    <div id="player" style="margin-top:10px"></div>
  </div>

  <!-- Screen 3: Done -->
  <div id="scrDone" class="card" style="display:none;">
    <b style="color:#16a34a;">‚úÖ Thank you! The recording session is complete.</b>
  </div>
</div>

<script>
/* ===== CONFIG ===== */
const API_BASE = "https://monkfish-app-c8mpr.ondigitalocean.app";

// Stage 1: Russian sentences only
const RUS_SENTS = [
  "–ù–∞—Å—Ç—É–ø–∏–ª–∞ –æ—Å–µ–Ω—å,",
  "–ê–Ω—Ç–æ–Ω —Å—Ç–æ–∏—Ç –Ω–∞ –º–æ—Å—Ç—É.",
  "–ö–∞–∫–∞—è –∑–∞–≤—Ç—Ä–∞ –±—É–¥–µ—Ç –ø–æ–≥–æ–¥–∞?",
  "–ì–¥–µ –º–æ–∂–Ω–æ –æ—Ç–¥–æ—Ö–Ω—É—Ç—å?",
  "–ú–æ–∂–Ω–æ —è –ø–æ–π–¥—É –≤ –∫–∏–Ω–æ?",
  "–û–Ω –ø—Ä–∏–µ–¥–µ—Ç –≤ –ø—è—Ç–Ω–∏—Ü—É –∏–ª–∏ –≤ —Å—É–±–±–æ—Ç—É?",
  "–ê –Ω–∞ —à–µ—Å—Ç–æ–º —ç—Ç–∞–∂–µ?",
  "–í–∞—à–µ –∏–º—è? (–ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏)",
  "–ö–∞–∫–æ–π —Å–µ–≥–æ–¥–Ω—è –¥–µ–Ω—å!",
  "–°–∫–æ–ª—å–∫–æ –¥–æ–±—Ä–æ—Ç—ã –≤ –Ω–µ–º!",
  "–ö–∞–∫–æ–π –≤–∫—É—Å–Ω–æ–π —Å–æ–∫!",
  "–°–∫–æ–ª—å–∫–æ —Å—Ç—É–¥–µ–Ω—Ç–æ–≤!",
  "–ö–∞–∫–æ–π –æ–Ω –æ—Ç–ª–∏—á–Ω–∏–∫! (—Ç–æ –µ—Å—Ç—å –æ–Ω –Ω–µ –æ—Ç–ª–∏—á–Ω–∏–∫)",
  "–î–∞ –∫–∞–∫–∞—è –æ–Ω–∞ –∞–∫—Ç—Ä–∏—Å–∞! (—Ç–æ –µ—Å—Ç—å –æ–Ω–∞ –Ω–µ –∞–∫—Ç—Ä–∏—Å–∞)"
];

// Stage 2: Russian text(s)
const TEXTS = [
  {
    title: "Text A",
    body: `–í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –≤–∞—à —Å–≤—è–∑–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º.

–ú–æ–∂–Ω–æ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–±–∑–∞—Ü–µ–≤.
–° –ø–µ—Ä–µ–Ω–æ—Å–∞–º–∏ —Å—Ç—Ä–æ–∫ ‚Äî –Ω–æ—Ä–º–∞–ª—å–Ω–æ.`
  }
];

// Two stages, one recording per item
const STAGES = [
  {
    name: "Stage 1 ‚Äî Russian sentences",
    promptLabel: "Sentence:",
    hint: "Read the sentence in Russian TWICE. Words in brackets do not need to be read.",
    items: RUS_SENTS.map((s, idx) => ({ id: `sent${idx+1}`, body: s }))
  },
  {
    name: "Stage 2 ‚Äî Russian text",
    promptLabel: "Text:",
    hint: "Read the text in Russian naturally at a comfortable pace.",
    items: TEXTS.map((t, idx) => ({ id: `text${idx+1}`, body: t.body, title: t.title }))
  }
];
/* =================== */

const $ = id => document.getElementById(id);
const show = (el,vis)=> el.style.display = vis ? "block" : "none";

function extFromMime(m){
  const t = (m||"").toLowerCase();
  if (t.includes("ogg")) return "ogg";
  if (t.includes("webm")) return "webm";
  if (t.includes("mp4")) return "m4a";
  if (t.includes("mpeg") || t.includes("mp3")) return "mp3";
  if (t.includes("wav")) return "wav";
  return "dat";
}

// Display counts (optional)
$("totalN").textContent = `${RUS_SENTS.length} sentences + ${TEXTS.length} text(s)`;

/* ===== State ===== */
let stage = 0;   // 0..STAGES.length-1
let item  = 0;   // 0..items.length-1
let pid = "";

let rec = null, chunks = [], mime = "", blobForSave = null;

// Mic check
let micRec=null, micChunks=[], micMime="", micReady=false;

/* ===== Mic Check ===== */
$("micEnable").onclick = async ()=>{
  try{
    const s = await navigator.mediaDevices.getUserMedia({audio:true});
    s.getTracks().forEach(t=>t.stop());
    micReady = true;
    $("micStatus").textContent = "‚úÖ Microphone permission granted.";
    $("micNext").disabled = false;
  }catch(e){
    $("micStatus").textContent = "‚ùå Unable to access microphone: " + (e && e.message || e);
  }
};

$("micRec").onclick = async ()=>{
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const prefs = ['audio/webm;codecs=opus','audio/ogg;codecs=opus','audio/mp4'];
    let chosen=''; for(const t of prefs){ if(MediaRecorder.isTypeSupported(t)){ chosen=t; break; } }
    micRec = new MediaRecorder(stream, chosen?{mimeType:chosen}:undefined);
    micMime = micRec.mimeType || chosen || '';
    micChunks = [];
    micRec.ondataavailable = e=>{ if(e.data?.size) micChunks.push(e.data); };
    micRec.onstop = ()=>{
      const b = new Blob(micChunks,{type:micMime||'audio/webm'});
      $("micPlayer").innerHTML = '<audio controls src="'+URL.createObjectURL(b)+'" style="width:100%"></audio>';
      $("micStop").disabled = true;
      micReady = true;
      $("micNext").disabled = false;
      $("micStatus").textContent = "‚úÖ Test recording ready (not saved).";
      stream.getTracks().forEach(t=>t.stop());
    };
    micRec.start();
    $("micStop").disabled = false;
    $("micStatus").textContent = "üî¥ Recording test‚Ä¶";
  }catch(e){
    $("micStatus").textContent = "‚ùå Unable to record test: " + (e && e.message || e);
  }
};

$("micStop").onclick = ()=>{ if(micRec && micRec.state==='recording') micRec.stop(); };

$("micNext").onclick = ()=>{
  if(!micReady){
    $("micStatus").textContent = "‚ùå Please enable mic or record a test first.";
    return;
  }
  show($("scrMic"), false);
  show($("scrId"), true);
};

/* ===== ID Screen ===== */
$("go").onclick = async ()=>{
  const v = ($("pid").value||"").trim();
  $("pidTaken").style.display = "none";
  if(!/^[A-Za-z0-9_-]+$/.test(v)){ $("warn").style.display = "block"; return; }
  $("warn").style.display = "none";
  pid = v;

  stage = 0; item = 0;

  show($("scrId"), false);
  show($("scrTask"), true);
  render();
};

/* ===== Render ===== */
function render(){
  const st = STAGES[stage];
  const it = st.items[item];

  $("prog").textContent = `${st.name} ‚Äî Item ${item+1} of ${st.items.length}`;
  $("phaseLabel").textContent = st.name;           // reuse existing slot
  $("hint").textContent = st.hint;

  $("promptLabel").textContent = st.promptLabel;

  $("sent").textContent = it.body;
  $("sent").style.whiteSpace = "pre-wrap"; // keep line breaks for text stage

  $("player").innerHTML = "";
  $("save").disabled = true;
  $("status").textContent = "Ready‚Ä¶";
  blobForSave = null;
}

/* ===== Recording ===== */
$("rec").onclick = async ()=>{
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const prefs = ['audio/webm;codecs=opus','audio/ogg;codecs=opus','audio/mp4'];
    let chosen=''; for(const t of prefs){ if(MediaRecorder.isTypeSupported(t)){ chosen=t; break; } }
    rec = new MediaRecorder(stream, chosen?{mimeType:chosen}:undefined);
    mime = rec.mimeType || chosen || '';
    chunks = [];
    blobForSave = null;

    rec.ondataavailable = e => { if(e.data?.size) chunks.push(e.data); };
    rec.onstop = ()=>{
      const b = new Blob(chunks,{type:mime||'audio/webm'});
      blobForSave = b;
      $("player").innerHTML = '<audio controls src="'+URL.createObjectURL(b)+'" style="width:100%"></audio>';
      $("save").disabled = false;
      $("status").textContent = "‚úÖ Recording ready to save.";
      stream.getTracks().forEach(t=>t.stop());
    };

    rec.start();
    $("rec").disabled = true;
    $("stop").disabled = false;
    $("save").disabled = true;
    $("status").textContent = "üî¥ Recording‚Ä¶";
  }catch(e){
    $("status").textContent = "‚ùå Unable to access microphone: " + (e && e.message || e);
  }
};

$("stop").onclick = ()=>{
  if(rec && rec.state==='recording'){
    rec.stop();
    $("rec").disabled = false;
    $("stop").disabled = true;
  }
};

/* ===== Save via presigned URL ===== */
async function saveRecording(){
  if(!blobForSave){
    $("status").textContent = "‚ùå No recording.";
    advance();
    return;
  }

  $("status").textContent = "‚è≥ Saving‚Ä¶";

  const st = STAGES[stage];
  const it = st.items[item];

  try{
    const ext = extFromMime(blobForSave.type);
    const stageTag = `S${stage+1}`;
    const itemTag = `I${String(item+1).padStart(3,'0')}`;
    const kindTag = st.promptLabel.toLowerCase().includes("text") ? "TEXT" : "SENT";

    // Safe ASCII key (no Cyrillic)
    const key = `sub${pid}_${stageTag}_${itemTag}_${kindTag}_${it.id}.${ext}`;

    const r = await fetch(`${API_BASE}/sign`, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({
        pid,
        key,
        content_type: blobForSave.type || `audio/${ext}`
      })
    });
    if(!r.ok) throw new Error("sign failed");
    const { url } = await r.json();

    const put = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": blobForSave.type || `audio/${ext}` },
      body: blobForSave
    });
    if(!put.ok) throw new Error("upload failed");

    $("status").textContent = "‚úÖ Saved.";
  }catch(e){
    $("status").textContent = "‚ö†Ô∏è Save failed. Moving on.";
  }

  advance();
}

$("save").onclick = saveRecording;

/* ===== Advance across items then stages ===== */
function advance(){
  const st = STAGES[stage];

  item++;
  if(item < st.items.length){
    render();
    return;
  }

  item = 0;
  stage++;
  if(stage < STAGES.length){
    render();
    return;
  }

  show($("scrTask"), false);
  show($("scrDone"), true);
}
</script>
</body>
</html>
